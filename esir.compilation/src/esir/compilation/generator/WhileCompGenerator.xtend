/*
 * generated by Xtext 2.10.0
 */
package esir.compilation.generator

import esir.compilation.whileComp.Affectation
import esir.compilation.whileComp.Command
import esir.compilation.whileComp.Commands
import esir.compilation.whileComp.Expr
import esir.compilation.whileComp.ExprAnd
import esir.compilation.whileComp.ExprEq
import esir.compilation.whileComp.ExprNot
import esir.compilation.whileComp.ExprOr
import esir.compilation.whileComp.ExprSimple
import esir.compilation.whileComp.Function
import esir.compilation.whileComp.Nil2
import esir.compilation.whileComp.Nop
import esir.compilation.whileComp.Program
import esir.compilation.whileComp.While
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhileCompGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(typeof(Program))){
			fsa.generateFile("Result_output.whpp",	e.compile)
		}
	}
	
	def compile (Program p){'''
		«FOR f : p.functions»
		«f.compile»
		«ENDFOR»
		'''
	}
	
	def compile (Function c){'''
		function «c.function»: 
		read «FOR param: c.definition.read.variable SEPARATOR ' ,'»«param»«ENDFOR»
		%
		«c.definition.commands.compile»
		%
		write «FOR param: c.definition.write.variable SEPARATOR ' ,'»«param»«ENDFOR»
		'''	
	}
	
	def compile(Commands coms){
		if(coms.commands != null){
			coms.commands.add(0,coms.command)
		}
		else{
			coms.command.compile()
		}
		'''
		«FOR c: (coms.commands) SEPARATOR ' ;'»«"	"»«c.compile»«ENDFOR»
		'''
	}
	
	def compile(Command c){
		'''
		«IF c.command instanceof Affectation»
			«(c.command as Affectation).compile»
		«ENDIF»
		«IF c.command instanceof Nop»
			nop
		«ENDIF»
		«IF c.command instanceof While»
			while «(c.command as While).expr.compile»	do
				«(c.command as While).commands.compile»
			«"	"»od
		«ENDIF»
		'''
	}
	
	def compile(Affectation aff){
		'''
		«FOR v: aff.affectations SEPARATOR ' ,'»«v»«ENDFOR» := «FOR v: aff.valeurs SEPARATOR ' ,'»«v»«ENDFOR»
		'''	
	}
	
	def compile(Expr expr){
		'''
		«IF expr.exprAnd != null»
		«expr.exprAnd.compile»
		«ENDIF»
		«IF expr.exprsimple != null»
		«expr.exprsimple.compile»
		«ENDIF»
		'''
	}
	
	def compile(ExprAnd expr){
		'''
		«IF expr.exprAnd == null»
		«expr.exprOr.compile»
		«ELSE»
		«expr.exprOr.compile» && «expr.exprAnd.compile»
		«ENDIF»
		'''
	}
	
	def compile(ExprOr expr){
		'''
		«IF expr.exprOr == null»
		«expr.exprNot.compile»
		«ELSE»
		«expr.exprNot.compile» || «expr.exprOr.compile»
		«ENDIF»
		'''
	}
	
	def compile(ExprNot expr){
		'''
		«IF expr.not != null»
		!«expr.exprEq.compile»
		«ELSE»
		!«expr.exprEq.compile»
		«ENDIF»
		'''
	}
	
	def compile(ExprEq expr){
		'''
		«IF expr.expr != null»
		(«expr.expr.compile»)
		«ELSE»
		«expr.exprSimple1.compile» =? «expr.exprSimple2.compile»
		«ENDIF»
		'''
	}
	
	def compile(ExprSimple expr){
		'''
		«IF expr.nil != null»
		nil
		«ENDIF»
		«IF expr.variable != null»
		«expr.variable»
		«ENDIF»
		«IF expr.symbol != null && expr.lexpr == null»
		«expr.symbol»
		«ENDIF»
		'''
	}
}