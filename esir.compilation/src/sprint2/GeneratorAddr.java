package sprint2;
/*
 * generated by Xtext 2.10.0
 */

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

import esir.compilation.WhileCompStandaloneSetup;
import esir.compilation.whileComp.Affectation;
import esir.compilation.whileComp.Command;
import esir.compilation.whileComp.Commands;
import esir.compilation.whileComp.Definition;
import esir.compilation.whileComp.Expr;
import esir.compilation.whileComp.ExprSimple;
import esir.compilation.whileComp.For;
import esir.compilation.whileComp.Foreach;
import esir.compilation.whileComp.Function;
import esir.compilation.whileComp.If;
import esir.compilation.whileComp.Program;
import esir.compilation.whileComp.Read;
import esir.compilation.whileComp.While;
import esir.compilation.whileComp.Write;

public class GeneratorAddr {

	private static final String PREFIXE = "X";

	// MAIN //
	public static void main(String[] args) {
		System.out.println("Constructing symbole table.");
		Injector injector = new WhileCompStandaloneSetup().createInjectorAndDoEMFRegistration();
		GeneratorAddr main = injector.getInstance(GeneratorAddr.class);
		try {
			main.createSymTable("../exemple3.wh", "./");
		} catch (SymTableException symEx) {
			System.out.println("[SYMTABLE ERROR] : " + symEx.getMessage());
		} catch (ThreeAddressCodeException codeEx){
			System.out.println("[ADDRCODE ERROR] : " + codeEx.getMessage());
		}
	}
	// ---- //

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	/**
	 * List of declared functions in the Program
	 */
	HashMap<String, DefFun> funList = new HashMap<String, DefFun>();
	ThreeAddressCode code3Addresses = new ThreeAddressCode();

	private void createSymTable(String string, String sortie) throws SymTableException, ThreeAddressCodeException {
		// Load the resource
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createFileURI(string), true);

		// Validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			for (Issue issue : list) {
				System.err.println(issue);
			}
			return;
		}

		TreeIterator<EObject> tree = resource.getAllContents();
		while (tree.hasNext()) {
			EObject next = tree.next();
			if (next instanceof Program)
				iterateAST((Program) next); // Parcours l'AST du 'Program'
		}

		System.out.println("Symboles Table correctly generated.");
	}

	
//ITERATE ON THE AST
	
	// Program
	private void iterateAST(Program prog) throws SymTableException, ThreeAddressCodeException {
		for (Function f : prog.getFunctions()) {
			iterateAST(f);
		}
		displaySymTable();
		System.out.println(code3Addresses);
	}
	
	// Function
	private void iterateAST(Function f) throws SymTableException, ThreeAddressCodeException {
		String fName = f.getFunction();
		code3Addresses.nouvelleEtiquette();

		boolean fun = funList.containsKey(fName);
		if (fun) { // Function already existing
			throw new SymTableException("Function '" + fName + "' already declared !");
		} else {
			DefFun def = new DefFun(fName);
			funList.put(fName, def); // Adding a new blank function
											// (DefFun)
			code3Addresses.addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.FUN, ""), fName, "", ""));
			iterateAST(f.getDefinition(), def);
		}
		code3Addresses.finEtiquette();
	}

	// Definition
	private void iterateAST(Definition def, DefFun f) throws SymTableException, ThreeAddressCodeException {
		// Inputs
		iterateAST(def.getRead(), f);
		// Commands
		iterateAST(def.getCommands(), f);
		// Outputs
		iterateAST(def.getWrite(), f);
	}

	// Read
	public void iterateAST(Read read, DefFun f) throws SymTableException{
		EList<String> varsR = read.getVariable();
		f.setIn(varsR.size());
		for (String v : varsR) {
			if(f.alreadyExisting(v)) throw new SymTableException("Function '"+f.getFunName()+"', variable '"+v+"' already declared !");
			f.updateVar(v, null);
			code3Addresses.addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.READ, ""), v, "", ""));
		}
	}

	// Write
	private void iterateAST(Write write, DefFun f) throws SymTableException{
		EList<String> varsW = write.getVariable();
		f.setOut(varsW.size());
		for (String v : varsW) {
			code3Addresses.addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.WRITE, ""), v, "", ""));
			f.updateVar(v, null);
		}
	}

	// Commands
	public void iterateAST(Commands coms, DefFun f) throws SymTableException, ThreeAddressCodeException {
		Command com = coms.getCommand();
		iterateAST(com, f); // First command of definition
		for (Command c : coms.getCommands()) { // Eventually other commands
			iterateAST(c, f);
		}
	}

	// Command
	private void iterateAST(Command com, DefFun f) throws SymTableException, ThreeAddressCodeException {
		EObject obj = com.getCommand();
		if (obj instanceof Affectation) { // Affectation
			iterateAST((Affectation) obj, f);
		} else {

			if (obj instanceof While) { // While
				iterateAST((While) obj, f);
			} else if (obj instanceof For) { // For
				iterateAST((For) obj, f);
			} else if (obj instanceof Foreach) { // Foreach
				iterateAST((Foreach) obj, f);
			} else if (obj instanceof If) { // If
				iterateAST((If) obj, f);
			} else {
			}
			code3Addresses.finEtiquette();
		}
	}

	// Affectation
	private void iterateAST(Affectation affCmd, DefFun f) throws SymTableException, ThreeAddressCodeException {
		EList<String> affs = affCmd.getAffectations();
		EList<Expr> vals = affCmd.getValeurs();

		if (vals.size() != affs.size())
			throw new ThreeAddressCodeException("Affectation error !");

		Iterator<String> itAff = affs.iterator();
		Iterator<Expr> itVal = vals.iterator();

		int i = 0;
		String val;
		String var;

		while (itVal.hasNext()) {
			//TODO: iterateAST(itVal.next()); // For Expr
			val = "nil";
			var = PREFIXE + i++;

			code3Addresses.addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.AFF, ""), var, val, ""));
			f.updateVar(var, val);
		}

		i = 0;
		while (itAff.hasNext()) {
			var = itAff.next();
			val = PREFIXE + i++;
			code3Addresses.addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.AFF, ""), var, val, ""));
			f.updateVar(var, val);
		}
	}
	
	//TODO : Expressions
	private void iterateAST(Expr exp, DefFun f){
		ExprSimple expSimp = exp.getExprsimple();
		iterateAST(expSimp, f);
		//TODO: ExprAnd
	}
	
	private void iterateAST(ExprSimple exp, DefFun f){
		//ExprSimple expSimp = exp.getExprsimple();
		//iterateAST(expSimp);
	}

	// While
	private void iterateAST(While whCmd, DefFun f) throws SymTableException, ThreeAddressCodeException {
		code3Addresses.addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.WHILE, ""), "", "", ""));
		code3Addresses.nouvelleEtiquette();
		Commands cmds = whCmd.getCommands();
		iterateAST(cmds, f);
	}

	// For
	private void iterateAST(For forCmd, DefFun f) throws SymTableException, ThreeAddressCodeException {
		code3Addresses.addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.FOR, ""), "", "", ""));
		code3Addresses.nouvelleEtiquette();
		Commands cmds = forCmd.getCommands();
		iterateAST(cmds, f);
	}

	// Foreach
	private void iterateAST(Foreach forEachCmd, DefFun f) throws SymTableException, ThreeAddressCodeException {
		Commands cmds = forEachCmd.getCommands();
		iterateAST(cmds, f);
	}

	// If
	private void iterateAST(If ifCmd, DefFun f) throws SymTableException, ThreeAddressCodeException {
		QuadImp q = new QuadImp(new OPCode<OP, String>(OP.IF, ""), ifCmd.getExpr().toString(), code3Addresses.getFutureEtiquette(), "");
		code3Addresses.addIn3Addr(q);
		//Then
		code3Addresses.nouvelleEtiquette();
		Commands cmds1 = ifCmd.getCommands1();
		iterateAST(cmds1, f);
		code3Addresses.finEtiquette();
		q.setArg2(code3Addresses.getFutureEtiquette());
		//Else
		code3Addresses.nouvelleEtiquette();
		Commands cmds2 = ifCmd.getCommands2();
		iterateAST(cmds2, f);
	}
	
	/**
	 * Print the final symboles table
	 */
	private void displaySymTable() {
		System.out.println();
		for (String f : funList.keySet()) {
			System.out.println(f + " : " + funList.get(f) + "\n");
		}
	}

	
}
