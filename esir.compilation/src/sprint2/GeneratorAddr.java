package sprint2;
/*
 * generated by Xtext 2.10.0
 */

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Stack;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.emf.ecore.resource.ResourceSet;
import org.eclipse.xtext.util.CancelIndicator;
import org.eclipse.xtext.validation.CheckMode;
import org.eclipse.xtext.validation.IResourceValidator;
import org.eclipse.xtext.validation.Issue;

import com.google.inject.Inject;
import com.google.inject.Injector;
import com.google.inject.Provider;

import esir.compilation.WhileCompStandaloneSetup;
import esir.compilation.whileComp.Affectation;
import esir.compilation.whileComp.Command;
import esir.compilation.whileComp.Commands;
import esir.compilation.whileComp.Definition;
import esir.compilation.whileComp.For;
import esir.compilation.whileComp.Foreach;
import esir.compilation.whileComp.Function;
import esir.compilation.whileComp.If;
import esir.compilation.whileComp.Program;
import esir.compilation.whileComp.Read;
import esir.compilation.whileComp.While;
import esir.compilation.whileComp.Write;

public class GeneratorAddr {

	private static final String PREFIXE = "X";

	// MAIN //
	public static void main(String[] args) {
		System.out.println("Constructing symbole table.");
		Injector injector = new WhileCompStandaloneSetup().createInjectorAndDoEMFRegistration();
		GeneratorAddr main = injector.getInstance(GeneratorAddr.class);
		try {
			main.createSymTable("../exemple3.wh", "./");
		} catch (SymTableException e) {
			System.out.println("[ERROR] : " + e.getMessage());
		}
	}
	// ---- //

	@Inject
	private Provider<ResourceSet> resourceSetProvider;

	@Inject
	private IResourceValidator validator;

	/**
	 * List of declared functions in the Program
	 */
	HashMap<String, DefFun> funList = new HashMap<String, DefFun>();;
	HashMap<String, LinkedList<QuadImp>> code3Addr = new HashMap<String,LinkedList<QuadImp>>();

	private Stack<LinkedList> stack = new Stack<LinkedList>();
	private LinkedList<LinkedList<QuadImp>> list3Addr = new LinkedList<LinkedList<QuadImp>>();

	private void createSymTable(String string, String sortie) throws SymTableException {
		// Load the resource
		ResourceSet set = resourceSetProvider.get();
		Resource resource = set.getResource(URI.createFileURI(string), true);

		// Validate the resource
		List<Issue> list = validator.validate(resource, CheckMode.ALL, CancelIndicator.NullImpl);
		if (!list.isEmpty()) {
			for (Issue issue : list) {
				System.err.println(issue);
			}
			return;
		}

		TreeIterator<EObject> tree = resource.getAllContents();
		while (tree.hasNext()) {
			EObject next = tree.next();
			if (next instanceof Program)
				iterateAST((Program) next); // Parcours l'AST du 'Program'
		}

		System.out.println("Symboles Table correctly generated.");
	}

	// Program
	private void iterateAST(Program prog) throws SymTableException {
		for (Function f : prog.getFunctions()) {
			iterateAST(f);
		}
		displaySymTable();
		display3Addr();
	}

	private void displaySymTable() {
		System.out.println();
		for (String f : funList.keySet()) {
			System.out.println(f + " : " + funList.get(f) + "\n");
		}

	}

	// Function
	private void iterateAST(Function f) throws SymTableException {
		String fName = f.getFunction();
		empilerEtiquette();

		boolean fun = funList.keySet().contains(f);
		if (fun) { // Function already existing
			throw new SymTableException("Function " + fName + " already declared !");
		} else {
			DefFun function = new DefFun();
			funList.put(fName, function); // Adding a new blank function
											// (DefFun)
			addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.FUN, ""), fName, "", ""));
			iterateAST(f.getDefinition(), function);
		}
		depilerEtiquette();
	}

	// Definition
	private void iterateAST(Definition def, DefFun f) throws SymTableException {
		// Inputs
		iterateAST(def.getRead(), f);
		// Commands
		iterateAST(def.getCommands(), f);
		// Outputs
		iterateAST(def.getWrite(), f);
	}

	// Read
	public void iterateAST(Read read, DefFun f) {
		EList<String> varsR = read.getVariable();
		f.setIn(varsR.size());
		for (String v : varsR) {
			f.updateVar(v, null);
			addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.READ, ""), v, "", ""));
		}
	}

	// Write
	private void iterateAST(Write write, DefFun f) {
		EList<String> varsW = write.getVariable();
		f.setOut(varsW.size());
		for (String v : varsW) {
			addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.WRITE, ""), v, "", ""));
			f.updateVar(v, null);
		}
	}

	// Commands
	public void iterateAST(Commands coms, DefFun f) throws SymTableException {
		Command com = coms.getCommand();
		iterateAST(com, f); // First command of definition
		for (Command c : coms.getCommands()) { // Eventually other commands
			iterateAST(c, f);
		}
	}

	// Command
	private void iterateAST(Command com, DefFun f) throws SymTableException {
		EObject obj = com.getCommand();
		if (obj instanceof Affectation) { // Affectation
			iterateAST((Affectation) obj, f);
		} else {

			if (obj instanceof While) { // While
				iterateAST((While) obj, f);
			} else if (obj instanceof For) { // For
				iterateAST((For) obj, f);
			} else if (obj instanceof Foreach) { // Foreach
				iterateAST((Foreach) obj, f);
			} else if (obj instanceof If) { // If
				iterateAST((If) obj, f);
			} else {
			}
			depilerEtiquette();
		}
	}

	// Affectation
	private void iterateAST(Affectation affCmd, DefFun f) throws SymTableException {
		EList<String> affs = affCmd.getAffectations();
		EList<String> vals = affCmd.getValeurs();

		if (vals.size() != affs.size())
			throw new SymTableException("Affectation error !"); // TODO

		Iterator<String> itAff = affs.iterator();
		Iterator<String> itVal = vals.iterator();

		int i = 0;
		String val;
		String var;

		while (itVal.hasNext()) {
			val = itVal.next();
			var = PREFIXE + i++;
			if (val.matches(PREFIXE + "[0-9]+")) {
				throw new SymTableException("Variable name reserved by the compiler.");
			}
			addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.AFF, ""), var, val, ""));
			f.updateVar(var, val);
		}

		i = 0;
		while (itAff.hasNext()) {
			var = itAff.next();
			val = PREFIXE + i++;
			addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.AFF, ""), var, val, ""));
			f.updateVar(var, val);
		}
	}

	// While
	private void iterateAST(While whCmd, DefFun f) throws SymTableException {
		addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.WHILE, ""), "", "", ""));
		empilerEtiquette();
		Commands cmds = whCmd.getCommands();
		iterateAST(cmds, f);
	}

	// For
	private void iterateAST(For forCmd, DefFun f) throws SymTableException {
		addIn3Addr(new QuadImp(new OPCode<OP, String>(OP.FOR, ""), "", "", ""));
		empilerEtiquette();
		Commands cmds = forCmd.getCommands();
		iterateAST(cmds, f);
	}

	// Foreach
	private void iterateAST(Foreach forEachCmd, DefFun f) throws SymTableException {
		Commands cmds = forEachCmd.getCommands();
		iterateAST(cmds, f);
	}

	// If
	private void iterateAST(If ifCmd, DefFun f) throws SymTableException {
		QuadImp q = new QuadImp(new OPCode<OP, String>(OP.IF, ""), ifCmd.getExpr().toString(), getFutureEtiquette(), "");
		addIn3Addr(q);
		empilerEtiquette();
		Commands cmds1 = ifCmd.getCommands1();
		iterateAST(cmds1, f);

		depilerEtiquette();
		q.setArg2(getFutureEtiquette());
		empilerEtiquette();
		Commands cmds2 = ifCmd.getCommands2();
		iterateAST(cmds2, f);
	}
	
	private String getEtiquetteName(int i){
		return "L"+i;
	}
	
	private String getEtiquette(){
		return getEtiquetteName(code3Addr.size());
	}
	
	private String getFutureEtiquette(){
		return getEtiquetteName(code3Addr.size()+1);
	}

	private void addIn3Addr(QuadImp q) {
		stack.lastElement().addLast(q);
	}

	private void empilerEtiquette() {
		stack.push(new LinkedList<QuadImp>());
	}

	private void depilerEtiquette() {
		//list3Addr.addFirst(stack.pop());
		code3Addr.put(getEtiquette(), stack.pop());
	}

	private void display3Addr() {
		StringBuilder sb = new StringBuilder();
		//Iterator<LinkedList<QuadImp>> iter = list3Addr.iterator();
		Iterator<Entry<String,LinkedList<QuadImp>>> iter = code3Addr.entrySet().iterator();
		int i = 0;
		while (iter.hasNext()) {
			Entry<String,LinkedList<QuadImp>> entry = iter.next();
			
			sb.append(entry.getKey()+":\t");
			Iterator<QuadImp> iter2 = entry.getValue().iterator();
			if(iter2.hasNext()){
				sb.append(iter2.next()+"\n");
			}
			while (iter2.hasNext()) {
				sb.append("\t"+iter2.next().toString()+"\n");
			}
			
			if (iter.hasNext()) {
				sb.append('\n');
			}
			i++;
		}
		System.out.println(sb.toString());
	}
}
