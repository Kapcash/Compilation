/*
 * generated by Xtext 2.10.0
 */
package org.xtext.compilation.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.compilation.whileComp.Affectation
import org.xtext.compilation.whileComp.Command
import org.xtext.compilation.whileComp.Commands
import org.xtext.compilation.whileComp.Expr
import org.xtext.compilation.whileComp.ExprAnd
import org.xtext.compilation.whileComp.ExprEq
import org.xtext.compilation.whileComp.ExprNot
import org.xtext.compilation.whileComp.ExprOr
import org.xtext.compilation.whileComp.ExprSimple
import org.xtext.compilation.whileComp.Function
import org.xtext.compilation.whileComp.Nil2
import org.xtext.compilation.whileComp.Nop
import org.xtext.compilation.whileComp.Program
import org.xtext.compilation.whileComp.While

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WhileCompGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		for (e : resource.allContents.toIterable.filter(typeof(Program))){
			fsa.generateFile("Result_output.whpp",	e.compile)
		}
	}
	
	def compile (Program p){'''
		«FOR f : p.functions»
		«f.compile»
		«ENDFOR»
		'''
	}
	
	def compile (Function c){'''
		function «c.function»: 
		read«FOR param: c.definition.read.variable SEPARATOR ','» «param»«ENDFOR»
		%
		«FOR f : c.definition.commands»
			«(f as Command).compile»
		«ENDFOR»
		%
		write«FOR param: c.definition.write.variable SEPARATOR ','» «param»«ENDFOR»
	'''	
	}
	
	def compile(Commands coms){
	'''
		«"	"»«coms.command.compile»
		«FOR c: (coms.commands)» ;
			«c.compile»
		«ENDFOR»
	'''
	}
	
	def compile(Command c){
		'''
		«IF c.command instanceof Affectation»
			«IF (c.command as Affectation).nil instanceof Nil2»
				«"	"»«(c.command as Affectation).affectation» := «(c.command as Affectation).nil.nil»
			«ELSE»
				«"	"»«(c.command as Affectation).affectation» := «(c.command as Affectation).valeur»
			«ENDIF»
		«ENDIF»
		«IF c.command instanceof Nop»
			«"	"»nop
		«ENDIF»
		«IF c.command instanceof While»
			«"	"»while «(c.command as While).expr.compile»	do
			«(c.command as While).commands.compile»
			«"	"»od
		«ENDIF»
		'''
	}
	
	def compile(Expr expr){
	'''
	«IF expr.exprAnd != null»
	«expr.exprAnd.compile»
	«ENDIF»
	«IF expr.exprsimple != null»
	«expr.exprsimple.compile»
	«ENDIF»
	'''
	}
	
	def compile(ExprAnd expr){
	'''
	«IF expr.exprAnd == null»
	«expr.exprOr.compile»
	«ELSE»
	«expr.exprOr.compile» && «expr.exprAnd.compile»
	«ENDIF»
	'''
	}
	
	def compile(ExprOr expr){
	'''
	«IF expr.exprOr == null»
	«expr.exprNot.compile»
	«ELSE»
	«expr.exprNot.compile» || «expr.exprOr.compile»
	«ENDIF»
	'''
	}
	
	def compile(ExprNot expr){
	'''
	«IF expr.not != null»
	!«expr.exprEq.compile»
	«ELSE»
	!«expr.exprEq.compile»
	«ENDIF»
	'''
	}
	
	def compile(ExprEq expr){
	'''
	«IF expr.expr != null»
	(«expr.expr.compile»)
	«ELSE»
	«expr.exprSimple1.compile» =? «expr.exprSimple2.compile»
	«ENDIF»
	'''
	}
	
	def compile(ExprSimple expr){
	'''
	«IF expr.nil != null»
	nil
	«ENDIF»
	«IF expr.variable != null»
	«expr.variable»
	«ENDIF»
	«IF expr.symbol != null && expr.lexpr == null»
	«expr.symbol»
	«ENDIF»
	'''
	}
}
